<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation" />
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool." />
    <title>Git Básico</title>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      
      .remark-slide-content {
        padding-left: 2.5em;
        padding-right: 2.5em;
        /*padding-top: 2em;*/
      }

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;        
        bottom: 0px;
        /*right: 0px;*/
      }
      .footnote:before {
        display: block;
        content: "Referências";
      }
      li p { line-height: 1.25em; }
      .ref { color: #428bca; }
      .large { font-size: 2em; }
      a, a > code {
        color: #428bca;
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .inverse h1 { font-size: 4em; }
      .inverse h2 { font-size: 3em; }
      .inverse h3 { font-size: 2em; }
      .author {
        position: relative;
        top: 100px;
      }
      .author a {
        color: inherit;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 15%;
        height: 92%;
        float: left;
        position: relative
      }
      .left-column h3:last-of-type {
        margin-top: 0px;
        margin-bottom: 1em;
      }
      .left-column h2:last-of-type,
      .left-column p:last-of-type {
        color: #000;
      }
      .right-column {
        width: 80%;
        float: right;
        padding-top: 1em;
      }
      .container {
        max-width: 500px;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <textarea id="source">



name: inverse
layout: true
class: center, middle, inverse
---
#Spring MVC
  
.author[
  Marlon Bernardes

  [github.com/marlonbernardes](https://github.com/marlonbernardes)
]


---
layout: false
.left-column[
  ## história
]
.right-column[
  Criado em abril de 2005, por Linus Torvalds, para versionar o [kernel do Linux](https://github.com/torvalds/linux)
  
  ### Critérios de design:  

  - Garantia contra corrupção de arquivos

  - Totalmente distribuído

  - Tomar o CVS como exemplo do que *não fazer*

    
  ### Metas:

  - Performance

  - Suporte a um workflow não-linear (branches paralelos)

  - Capacidade de gerenciar projetos gigantes (kernel do Linux)
]


---
template: inverse
## conceitos
## comandos
## workflow


---
template: inverse
## git básico
### conceitos


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos
]
  .right-column[
   ## Como git armazena arquivos
   ### Snapshots, não deltas

  A cada commit:
  - se um arquivo **foi modificado**, git armazena um snapshot do arquivo e guarda uma referência ao snapshot;  

  - se um arquivo **não foi modificado**, git guarda um link para o arquivo idêntico anteriormente já armazenado (eficiência, tamanho menor)

  ![](./img/1-5.png)

  .footnote[
    Referências:
    [1](http://stackoverflow.com/questions/5176225/are-gits-pack-files-deltas-rather-than-snapshots)
    [2](http://stackoverflow.com/questions/8198105/how-does-git-store-files)
  ]
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais
]
  .right-column[
   ## Quase todas operações são locais

  Cada cliente tem todo o histórico do projeto na sua máquina local

  Com git, trabalhamos localmente. Tudo o que fizermos na máquina local não impacta o código no servidor, enquanto não for sincronizado

  Workflow mais rápido e possibilidade de fazer quase tudo offline

  ### Exemplos de operações locais:
  ```
  status, add, commit, log, diff, branch, checkout, merge, 
  rebase, stash ...
  ```

  ### Exemplos de operações que se comunicam com o servidor:
  ```
  clone, pull, fetch, push
  ```
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais

  integridade
]
.right-column[
   ## Git garante integridade

  Todo objeto no git passa por um check-sum antes de ser armazenado
  
  Após o check-sum, o objeto passa a ser referenciado pelo hash gerado
  
  Usa a função SHA-1. Produz um hash de 40 caracteres hexadecimais:
  ```
  70460b4b4aece5915caf5c68d12f560a9fe3e4
  ```

  Qualquer modificação em um arquivo, mesmo de um único caracter, gera um hash **completamente** diferente
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais

  integridade

  baixo risco de perda
]
.right-column[
  ## Geralmente, git só *adiciona* dados

  Quase todas as ações do usuário apenas adicionam dados à base de dados do git. Quase nada remove dados

  Isso significa que, uma vez feito o commit de um arquivo, quase tudo pode ser desfeito, pois dificilmente algum dado é perdido

  Permite experimentar sem causar danos ao projeto
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais

  integridade

  baixo risco de perda

  3 estados / 3 seções  
]
.right-column[
  ## 3 estados dos arquivos, 3 seções do projeto
  ### Um arquivo versionado está sempre em 1 de 3 estados:

  - **modified** (modificado): arquivo que foi modificado, em relação ao snapshot (commit) mais recente em que ele aparece

  - **staged** (preparado): arquivo que foi modificado e, em um estado específico, foi marcado para entrar no próximo commit
  
  - **committed** (consolidado): arquivo que teve um snapshot de uma versão específica sua armazenado na base de dados do git 
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais

  integridade

  baixo risco de perda

  3 estados / 3 seções    
]
.right-column[
  ## 3 estados dos arquivos, 3 seções do projeto
  ### Relacionado a cada estado possível de um arquivo, está uma seção de um projeto versionado pelo git:
  
  - **working directory, working area, workspace** (diretório de trabalho): trabalhamos aqui. É simplesmente a pasta do projeto, onde o git disponibiliza (checkout) os arquivos do projeto como eles estavam em um determinado momento (ou seja, um snapshot do projeto).

  - **staging area, index** (área de preparação): é um índice que mantém uma lista de todos os arquivos modificados que irão compor o próximo commit. É na verdade um único arquivo, que referencia todos os arquivos staged.

  - **git directory, local repository** (diretório do git): quando temos arquivos na staging area e fazemos um commit, git faz um snapshot, gera um hash e armazena cada arquivo no git directory. É simplesmente um diretório oculto, chamado `.git`, que fica na raíz do projeto.
]


---
layout: false
.left-column[
  ## git básico
  ### conceitos
  arquivos

  operações locais

  integridade

  baixo risco de perda

  3 estados / 3 seções    
]
.right-column[
  ## 3 estados dos arquivos, 3 seções do projeto
  .center[![](./img/2-1.png)]
  .center[![](./img/1-6.png)]  
]


---
template: inverse
## git básico
### comandos


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init
]
.right-column[
  ## Inicializando um repositório
  
  Para inicializar um repositório git no seu, executar na pasta do projeto:
  
  ```
  > git init
  ```

  `git init` gera a o git directory, uma pasta oculta chamada .git. Para remover o git do seu projeto, basta excluir essa pasta.
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status
]
.right-column[
  ## Status dos arquivos
  
  De longe, o comando git mais usado:

  ```
  > git status
  ```

  Mostra cada arquivo modified, staged ou untracked, e sugestões de comandos que se aplicam a cada estado
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status

  add  
]
.right-column[
  ## Monitorando (*tracking*) novos arquivos
  *Untracked* é um arquivo que não está na base de dados do git. São os novos arquivos adicionados ao projeto, ou seja, arquivos que o git ainda não "monitora".

  *Tracked* é um arquivo que já está versionado, que já está na base de dados do git.
  
  Por padrão, git não irá incluir arquivos *untracked* nos seus commits, a menos que você os torne explicitamente *tracked*.

  ```
  > git add <file>
  ```  
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status

  add
]
.right-column[
  ## Preparando arquivos modificados para o próximo commit
  Quando modificamos um arquivo *tracked*, git considera o arquivo modificado.

  Mas o arquivo está modificado apenas no working directory. Para prepará-lo para entrar no próximo commit, precisamos colocá-los na staging area.
  
  ```
  > git add <file>
  ```

  O que vai para a staging area não é simplesmente o arquivo, mas sim a versão específica do arquivo no momento em que ele foi adicionado. Isso permite que um mesmo arquivo tenha uma versão staged e uma versão modified.

  `git add` é um comando multi-purpose, que serve para adicionar arquivos modificados para a staging area, mas também torna arquivos untracked em tracked (e já os coloca na staging area também)
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status
  
  add

  diff
]
.right-column[
  ## Visualizando alterações
  Comparar **working directory** com **staging area** (o que está modified mas não staged):
  ```
  > git diff
  ```  

  Comparar **staging area** com o **git directory**, especificamente, com o commit no qual se deu checkout (o que está staged mas não commited):
  ```
  > git diff --staged // ou git diff --cached
  ```
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status
  
  add

  diff

  commit  
]
.right-column[
  ## Commit 
  Quando a sua staging area estiver com as alterações desejadas, você pode fazer o commit de suas alterações.

  Fará parte do commit somente o que estiver na staging area (arquivos modified ou untracked não serão farão parte).

  Lembrar que, ao fazer um commit, git tira um snapshot do estado de todos os arquivos do projeto, e guarda esse estado referenciado pelo hash SHA-1 gerado.

  A cada commit está associada uma mensagem descritiva das alterações.

  ```
  > git commit // abre o editor de texto para escrever a mensagem
  ``` 
  ```
  > git commit -m 'mensagem do commit'
  ```   
  ```
  > git commit -a -m 'commit pulando a staging area'
  ```   
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status
  
  add

  diff

  commit 

  log 
]
.right-column[
  ## Visualizando o histórico do projeto 

  Mostra o histórico dos commits do projeto.
  
  ```
  > git log
  ```
  ```
  > git log --oneline // versão mais resumida e legível
  ```
  
  Repare que os commits são referenciados pelos caracteres iniciais do seu hash.
]


---
layout: false
.left-column[
  ## git básico
  ### comandos
  init

  status
  
  add

  diff

  commit 

  log

  reset / checkout

  .footnote[
    [1](http://git-scm.com/book/en/Git-Basics-Undoing-Things)
    |
    [2](https://www.atlassian.com/en/git/tutorial/undoing-changes#!checkout)
    |
    [3](http://git-scm.com/blog/2011/07/11/reset.html)
  ] 
]
.right-column[
  ## Desfazendo

  *Unstage*, o efeito contrário ao `git add` - tirar um arquivo da staging area (o arquivo continua modificado no working directory):
  ```
  > git reset <file> // ou . para todos os arquivos na staging
  ```
  
  *Unmodify*, reverter alterações do arquivo desde o último commit:
  ```
  > git checkout -- <file>
  ```
  Este comando não pode ser desfeito. Git não terá como recuperar as alterações revertidas, pois elas nunca fizeram parte de um commit, ou seja, nunca foram armazenadas pelo git.

  Reverter projeto ao estado do último commit:
  ```
  > git reset --hard
  ```
]


---
template: inverse
## git básico
### workflow


---
layout: false
.left-column[
  ## git básico
  ### workflow
]
.right-column[
  (Usar `git status` para acompanhar o efeito de cada comando.)
  
  Inicializar o repositório dentro da pasta do projeto:
  
  ```
  > git init
  ```  

  O projeto já existe, já tem arquivos?

  - Sim: adicionar todo o projeto para a staging area e fazer um commit inicial:
  ```
  > git add . // . é referência para "o diretório atual"
  > git commit -m 'initial commit'
  ```

  - Não: criar os arquivos do projeto, trabalhar normalmente. Quando tiver um ou mais arquivos, fazer um commit inicial.
  

  Quando quiser fazer um commit, adicionar os arquivos desejados para a staging area e fazer o commit:
  ```
  > git add file1 file2 // ou . para todos os arquivos modificados
  > git commit -m 'mensagem descritiva do commit'
  ```
  
  Repetir o passo anterior sempre que necessário.
]


---
template: inverse
## branching
### conceitos


---
layout: false
.left-column[
  ## branching
  ### conceitos
  commits
]
.right-column[
  ## Commits e branches

  Cada commit tem 0 ou mais referências a outros commits, que são seus pais.

  Normalmente um commit tem 1 pai, mas o primeiro commit do projeto tem 0 pais, e um commit que resulta de um merge terá 2 ou mais pais.
  
  Um branch é, tecnicamente, uma referência móvel a um commit específico. O branch padrão do git se chama *master*
  
  ![](./img/3-3.png)

  No exemplo, master é uma referência para um commit (um ponto na linha do tempo do projeto). Cada commit aponta para seu pai, e o primeiro não aponta para nenhum commit. Se criarmos um novo commit, master irá apontar para ele e ele irá apontar para f30ab.
]


---
layout: false
.left-column[
  ## branching
  ### conceitos
  commits

  branches
]
.right-column[
  ## Branches
  Um novo branch é criado a partir de um commit existente em um outro branch. Por exemplo: estamos em *master*, e criamos um branch *iss53*. *master* e *iss53* são referências para commits, que nesse momento apontam para o mesmo commit C2:
  
  ![](./img/3-11.png)

  Podemos trabalhar separadamente em *master* e *iss53*:

  ![](./img/3-15.png)  
]


---
layout: false
.left-column[
  ## branching
  ### conceitos
  commits

  branches

  HEAD
]
.right-column[
  ## HEAD
  
  HEAD é uma referência para o branch ou commit que está disponibilizado no nosso working directory.

  Ou seja, HEAD é uma referência para o branch ou commit no qual "estamos".

  Se "estamos" no master, HEAD aponta para o master. Se "estamos" no branch iss53, HEAD aponta para iss53. Na verdade, sempre "estamos" no HEAD.

  Se HEAD apontar para um commit específico (e não para um branch - que é por sua vez é um ponteiro móvel para um commit), não "estamos" em nenhum branch, mas sim diretamente em um commit. Isso é o "detached HEAD state": HEAD não está apontando para um branch.
]


---
layout: false
.left-column[
  ## branching
  ### conceitos
  commits

  branches
  
  HEAD
  
  merge
]
.right-column[
  ## Merge
  
  Branches nos permitem seguir diferentes linhas do tempo no projeto.

  É comum criar um branch temporário para trabalhar em uma atividade, e após finalizá-la, trazer as alterações feitas no branch temporário para o master e apagar o branch temporário.

  ![](./img/3-17.png)

  O processo de unir dois branches em um commit é o *merge*.

  No exemplo, o commit C6 foi originado a partir do merge dos branches master e iss53. C6 tem dois commits pais: C4 e C5.
]


---
template: inverse
## branching
### comandos


---
layout: false
.left-column[
  ## branching
  ### comandos
  branch
]
.right-column[
  ## Visualizando, criando e apagando branches

  Lista os branches locais:
  ```
  > git branch
  ```  
  
  Cria um branch chamado task56 (apontando para o commit atual):
  ```
  > git branch task56
  ```  
  
  Apaga o branch task56:
  ```
  > git branch -d task56 // -D para apagar alterações não salvas
  ```   
]


---
layout: false
.left-column[
  ## branching
  ### comandos
  branch

  checkout
]
.right-column[
  ## Trocando de branch
  
  Para trocarmos do branch *master* para o branch *task56*:
  ```
  > git checkout task56
  ```  
  
  *task56* é um branch. Branches são referências móveis para commits. O que acontece na verdade é que git procura na sua base de dados o snapshot do projeto relativo ao commit para o qual *task56* aponta, e coloca no working directory esse snapshot do projeto.
  
  Para criar um branch e ir para ele em um só comando:
  ```
  > git checkout -b bug23 // = git branch bug23 + git checkout bug23
  ```  
  
  É recomendado criar um novo branch estando com o work state limpo (sem arquivos modified ou staged). Ou seja, criar um branch após um commit ou um reset. [TODO verificar se é reset ou mais alguma opção]

  Existem também outras técnicas para contornar essa situação (como o [stash](http://git-scm.com/book/en/Git-Tools-Stashing)).
]


---
layout: false
.left-column[
  ## branching
  ### comandos
  branch

  checkout
]
.right-column[
  ## Explicando o checkout
  
  Checkout na verdade é o processo do git buscar um objeto na sua base de dados (git directory) e disponibizá-lo no working directory.

  O checkout pode ser usado com arquivos, commits e branches:

  - Checkout de um branch:
  ```
  > git checkout <branch>
  ```  
  
  - Checkout de um commit (permite voltar na linha do tempo):
  ```
  > git checkout <commit> // detached HEAD state
  ```

  - Checkout de um arquivo, no estado em que ele estava em um commit específico:
  ```
  > git checkout <commit> <file>
  ```
]


---
layout: false
.left-column[
  ## branching
  ### comandos
  branch

  checkout

  merge
]
.right-column[
  ## Merge
  
  Se quisermos introduzir as alterações feitas em *task56* no *master*, fazemos o merge entre os dois:
  ```
  > git merge task56 // estou no master
  ```  

  Git normalmente resolve merges automaticamente, a menos que a mesma linha de um arquivo tenha sido alterada de forma diferente em ambos branches.

  Nesse caso, git não tem como saber qual das alterações deve ficar no arquivo e a escolha cabe ao usuário. Após resolver o merge manualmente, deve-se fazer um commit da resolução do merge.
]


---
template: inverse
## branching
### workflow

---
layout: false
.left-column[
  ## branching
  ### workflow
]
.right-column[
  Estes exemplos usam branching apenas localmente. Na prática, branches são muito usados para trabalhar com remotes.

  HEAD está em master, o work state (working directory e staging area) está limpo. Criamos um branch temporário para trabalhar em uma tarefa:
  ```
  > git checkout -b task44
  ```
  
  Trabalhamos no branch task44, fazendo commits conforme necessário.

  Quando estiver concluída a tarefa, vamos para o master integramos o branch task44 com o master:
  ```
  > git checkout master
  > git merge task44
  ```

  Quando quisermos deletar o branch temporário:
  ```
  > git branch -d task44
  ```
]


---
layout: false
.left-column[
  ## branching
  ### workflow
]
.right-column[
  Podemos também manter diversos branches simultaneamente, se for necessário.

  Se estivermos no branch task44 e precisarmos corrigir com urgência o bug 22, podemos fazer:
  ```
  > git checkout master
  > git checkout -b bug22 // criar bug22 a partir do master!

  // ... corrigir o bug 22, fazer os commits necessários ...
  
  > git checkout master
  > git merge bug22 // integrar bug22 com o master
  > git checkout task44 // continuar trabalhando normalmente no task44
  ```
]


---
template: inverse
## trabalhando com remotes
### conceitos


---
layout: false
.left-column[
  ## remotes
  ### conceitos
]
.right-column[
  ## Repositórios remotos
  
  *Remotes* são repositórios remotos em servidores. Servem para compartilhar o projeto, e como backup em relação à máquina do desenvolvedor.
  
  Ninguém trabalha diretamente no remote, mas todos mantém seu repositório local atualizado com o remote, enviando e recebendo as alterações.
  
  O remote padrão de um projeto git é o **origin**. Git automaticamente chama de origin o servidor do qual você fizer o clone do projeto.
  
  Para visualizar os seus remotes:
  ```
  > git remote // -v para mostrar a URL
  ```
  
  É bastante comum trabalharmos com apenas 1 remote (geralmente em uma plataforma como o [GitHub](https://github.com/), [GitLab](https://gitlab.com/users/sign_in) ou [BitBucket](https://bitbucket.org/)).
]


---
layout: false
.left-column[
  ## remotes
  ### conceitos
]
.right-column[
  ## Repositórios remotos
  
  É importante lembrar que cada cliente tem uma cópia completa do repositório no seu computador.

  Os commits acontecem localmente, e as alterações só são recebidas ou enviadas quando o cliente usar os comandos apropriados.

  Se duas pessoas trabalharem simultaneamente no mesmo branch e cada uma fizer um commit com uma alteração na mesma linha de um arquivo, haverá a necessidade de fazer um merge dessas alterações.

  O merge será resolvido localmente. A primeira pessoa irá atualizar o remote sem problemas. A segunda pessoa terá que baixar as atualizações da primeira, resolver o merge no seu computador, fazer um commit do merge, e só então poderá enviar suas alterações para o remote.  
]


---
template: inverse
## trabalhando com remotes
### comandos


---
layout: false
.left-column[
  ## remotes
  ### comandos
  clone 
]
.right-column[
  ## Clonando um repositório
  
  Para clonar na máquina local um repositório remoto já existente:

  ```
  > git clone <url>
  ```

  Juntamente com `git init`, esta é a outra forma de iniciar um repositório na sua máquina local.

  Ao clonar um projeto, o remote origin já é setado por padrão com a url da qual fizemos o clone.

  Se iniciamos um projeto através do `git init`, git já cria o remote origin, mas sem uma url relacionada. Se criarmos um repositório no GitHub e quisermos vincular o nosso projeto local a ele, usamos:
  ```
  > git remote set-url origin <url>
  > git push -u origin master // manda o branch para o remote
  > git remote -v // visualizar remotes e suas urls
  ```

  [1](http://stackoverflow.com/questions/5561295/what-does-git-push-u-mean)
]


---
layout: false
.left-column[
  ## remotes
  ### comandos
  clone 

  pull
]
.right-column[
  ## Recebendo dados do remote
  
  Para atualizar um branch local, damos checkout nele e usamos:

  ```
  > git pull <remote> <branch>
  ```
  Isso atualiza o branch local **atual** com o conteúdo do branch `<branch>` no remote.

  Se quisermos baixar o conteúdo de um branch que não temos localmente, podemos usar:
  ```
  > git fetch // atualiza localmente os remote-tracking branches
  > git checkout --track <remote>/<branch> // cria o branch local
  ```
  `git fetch` atualiza os [remote-tracking branches](http://git-scm.com/book/en/Git-Branching-Remote-Branches). Em resumo, são branches que não alteramos diretamente, mas sim que refletem (localmente) o estado dos branches do remote.

  A alteração que o fetch faz nos remote-tracking branches não é refletida imediatamente nos nossos branches. Por isso, criamos o novo branch e explicitamos qual remote-tracking branch ele se refere.
]


---
layout: false
.left-column[
  ## remotes
  ### comandos
  clone 

  pull

  push
]
.right-column[
  ## Enviando dados para o remote
  
  Para atualizar o remote a partir de um branch local, damos checkout nele e usamos:

  ```
  > git push <remote> <branch>
  ```

  Se, desde o nosso último pull, alguém fez um push de um commit que irá conflitar com o commit que vamos dar push, não conseguiremos dar o push.

  Teremos que primeiro dar pull, resolver o merge localmente, fazer um commit da resolução do merge, e então dar push.
]


---
template: inverse
## trabalhando com remotes
### workflow


---
layout: false
.left-column[
  ## remotes
  ### workflow
]
.right-column[
  (Exemplo de [centralized workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/centralized-workflow))

  Clonamos o projeto:
  ```
  > git clone <url>
  ```

  Trabalhar normalmente, fazendo os commits necessários.

  Podemos, após um commit, aproveitar o work state limpo e dar pull dos commits feitos por outras pessoas:
  ```
  > git pull origin master
  ```

  Quando quisermos subir nossos commits:
  ```
  > git pull origin master // primeiro baixar commits de outros

  // pode ser necessário resolver um merge manualmente nesse momento.
  // se for esse o caso, fazer um commit com a resolução do merge.

  > git push origin master
  ```

  Este é um workflow simples, similar ao usado no SVN, mostrado como exemplo. Existem outros workflows que são melhores para se trabalhar com git, como o [feature branch workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow).
]


---
template: inverse
## créditos


---
layout: false
class: middle, center

.container[
  Estes slides são baseados em grande parte no livro [Pro Git](http://git-scm.com/book), escrito por Scott Chacon e publicado pela Apress. A apresentação cobre resumidamente os 3 primeiros capítulos do livro.

  Todas as imagens utilizadas nestes slides são do livro Pro Git.

  Os slides foram feitos utilizando [remark](https://github.com/gnab/remark).
]


---
template: inverse
## referências


---
layout: false
class: middle, center

[Docs](http://git-scm.com/doc)

[Pro Git - Online Book](http://git-scm.com/book)

[CodeSchool tryGit](http://try.github.com/)

[Git Immersion](http://gitimmersion.com/)

[Atlassian Git Tutorials](https://www.atlassian.com/git/tutorials/)

[Git - The Simple Guide](http://rogerdudler.github.io/git-guide/)

[Git Cheat Sheet - GitHub](https://training.github.com/kit/downloads/github-git-cheat-sheet.pdf)

[Git Cheat Sheet - NDP Software](http://www.ndpsoftware.com/git-cheatsheet.html)


---
template: inverse
#git básico  
  
.author[
  Rafael Eyng

  [github.com/rafaeleyng](https://github.com/rafaeleyng)
]







    </textarea>
    <script src="assets/js/remark.js"></script>
    <script type="text/javascript">
       var hljs = remark.highlighter.engine;
    </script>
    <script src="assets/js/remark.language.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>